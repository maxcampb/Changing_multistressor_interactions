---
title: "Photosynthesis_diuron"
author: "Max Campbell, Chris Brown, Olivia King"
date: "24/05/2021"
output: html_document
---


```{r}

library(tidyverse)
library(mgcv)
library(visreg)

psii_dat <- read_csv("../Data/diuron_light_PSII_long_NEW.csv") %>% 
  rename(hours = `Time (hours)`, Diuron = `Diuron (ug/L)`,
         Light_num = `Light (u mol photons m/s/)`, block = Block) %>% 
  group_by(hours, Light_num, Diuron, block) %>% 
  summarise(photo_inhib = mean(`Photosynthetic inhibition (%)`), 
                               Yield = mean(`Y(II)`), 
                               Yield_C = mean(`Average Y (controls)`, na.rm = TRUE)) %>% 
  within({
    
    hours[hours == 0.3] <- 0.33
    
    Diuron_num <-  case_when(Diuron == "Control" ~ 0,
                             Diuron == "MeOH" ~ 0,
                             TRUE ~ as.numeric(Diuron)
                             )
  
    block <-  factor(as.character(block))
    
    hours_fact <- factor(hours)
    
    t0 <- ifelse(hours == 0, Yield, NA)
    inhibt0 <- ifelse(hours == 0, photo_inhib, NA)
    
    }) %>% group_by(Light_num, Diuron, block ) %>% 
  fill(t0, inhibt0) %>% ungroup() %>% 
  mutate(sample_id = factor(gsub("."," ", x = paste(Diuron, Light_num, block), fixed = TRUE))) %>% 
  filter(Diuron != "MeOH", hours != 0)

```

# Analysis of Diuron and light 

Below pools meth control and control. 

```{r}
ggplot(psii_dat) + 
  aes(x = hours, y = photo_inhib, color = factor(Diuron_num)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()

ggplot(psii_dat) + 
  aes(x = hours, y = photo_inhib, color = factor(block)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()

ggplot(psii_dat) + 
  aes(x = hours, y = Yield, color = factor(Diuron_num)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()

ggplot(psii_dat) + 
  aes(x = hours, y = Yield, color = factor(block)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()

```

```{r}

# psii_dat2 <- psii_dat %>% filter(Diuron_num != 0)
# 
# m1_diuron_inhib <- gam(photo_inhib ~ s(hours, k = 5) + 
#                          offset(inhibt0)+
#                       s(Diuron_num, Light_num, k = 12, by = hours_fact) +  
#                         s(sample_id, bs = "re")+
#                        # s(Light_num, k = 3, by = hours_fact) +
#                        # s(Diuron_num, k = 5, by =hours_fact) +
#                       s(block, bs = "re"), 
#                     data = psii_dat2)

m1_diuron_yield <- gam(Yield ~ s(hours, k = 5) + 
                         offset(t0)+
                      s(Diuron_num, Light_num, k = 15, by = hours_fact) +  
                        #s(sample_id, bs = "re")+
                       #s(Light_num, k = 3, by = hours_fact) +
                       #s(Diuron_num, k = 5, by =hours_fact) +
                      s(block, bs = "re"),
                    data = psii_dat)

par(mfrow = c(2,2))
#gam.check(m1_diuron_inhib)
gam.check(m1_diuron_yield, rep = 500)

```

```{r}

png(filename = "../Outputs/fluoro_Diuron_GAM_residuals.png", width = 20, height = 20, units = "cm", res = 300)
par(mfrow = c(2,2))
gam.check(m1_diuron_yield)
dev.off()

```

Everythign matters here, include block. 

```{r}
summary(m1_diuron_yield)
```

74% of variance is explained. 


Model fit for celld by time

```{r}
visreg(m1_diuron_yield, xvar = "hours")
```
Effect of Diuron and light at zero hours

```{r}
visreg(m1_diuron_yield, xvar = "Light_num", by = "Diuron_num",
cond = list(hours = 24))
```

Effect of DIN and light at 72 hours 
```{r}
visreg(m1_diuron_yield, xvar = "Light_num", by = "Diuron_num",
cond = list(hours = 72))

```

#### Make credible interval functions
```{r}

## MVN random deviates function
rmvn <- function(n,mu,sig) {
  L <- mroot(sig)
  m <- ncol(L)
  t(mu + L%*%matrix(rnorm(m*n),m,n)) 
}

### Function to compute the credible interval data

compute_CI_data <- function(model, dat, nsims = 1000){
  
  Xp <- predict(model,dat,type="lpmatrix") # Get linear predictor matrix minus the offset

  which_re <- grepl("block|sample", names(coef(model)))
  mean_block_effect <- coef(model)[grepl("block", names(coef(model)))] %>% mean()
  #mean_sample_id_effect <- coef(model)[grepl("sample", names(coef(model)))] %>% mean()
  
  # 1000 replicate param. vectors
  br <- rmvn(nsims,coef(model),model$Vp) 
  
  # Remove random effects columns to make condition on average random effect levels
  Xp <- Xp[,!which_re]
  br <- br[, !which_re]
  

# Intialise the matrix for storage of celld estimates
celldmult <- matrix(NA, nrow = nrow(dat), ncol = nsims)

for (i in 1:nsims){ 
  pr <- Xp %*% br[i,] + mean_block_effect #+ mean_sample_id_effect ## replicate predictions
  celldmult[,i] <- pr 
}

# Convert predictions to the natural scale (added offset here) and bind to the data
df_bayes <- cbind(dat, celldmult + dat$t0) 

return(df_bayes)

}

```



### Diuron proportion inhib LRR plots 

This doesn't really make sense to do as they are already compared to Diuron = 0)


```{r}
# # Generate some data for prediction
# xdiuron_newdata <- with(psii_dat2,{
#   expand.grid(list(Light_num = unique(Light_num), Diuron_num = unique(Diuron_num), hours = unique(hours)))}) %>%
#   mutate(block = 2, sample_id = psii_dat2$sample_id[[1]], hours_fact = factor(hours), inhibt0 = 0) 
# 
# # Make predictions based 
# set.seed(1000)
# diuron_bayes <- compute_CI_data(model = m1_diuron_inhib, dat = xdiuron_newdata, nsims = 1000) %>% within({
#   Treatment <- case_when(Light_num == 20  ~ "Diuron_only",
#                          Diuron_num == 0  ~ "Light_only",
#                         TRUE ~ "Light_Diuron")
#   }) 
# 
# # # Generate the control matrix
# # diuron_bayes_control <- diuron_bayes %>% filter(Treatment == "Control")
# # diuron_control_mat <- diuron_bayes_control[ match(diuron_bayes$hours, diuron_bayes_control$hours) ,]
# 
# # Generate light only matrix
# diuron_bayes_light <- diuron_bayes %>% filter(Treatment == "Light_only")
# diuron_light_mat <- diuron_bayes_light[ match(diuron_bayes$hours, diuron_bayes_light$hours) ,]
# 
# # Generate diuron only matrix
# diuron_bayes_diuron <- diuron_bayes %>% filter(Treatment == "Diuron_only")
# diuron_mat <- diuron_bayes_diuron[ match(diuron_bayes$hours, diuron_bayes_diuron$hours) ,]
# 
# # Compute the IR matrix
# IR_mat2 <- log(select(diuron_bayes, `1`:`1000`)/
#                 (select(diuron_light_mat, `1`:`1000`)+select(diuron_mat, `1`:`1000`)))
# 
# rowSums(is.na(IR_mat2))
# IR_mat2[is.na(IR_mat2)] <- 10
# 
# # Compute the credible intervals
# Diuron_CItrend3 <- cbind(data.frame(t(apply(IR_mat2, 1, quantile, probs = c(0.025, 0.5, 0.975), na.rm = TRUE))), xdiuron_newdata) %>% within({
#   Treatment <- case_when(#Light_num == 20 & Diuron_num == 0 ~ "Control",
#                          Light_num == 20  ~ "Diuron_only",
#                          Diuron_num == 0  ~ "Light_only",
#                         TRUE ~ paste0("Light = ", Light_num, ", Diuron = ", Diuron_num))}) %>% 
#   filter(!(Treatment %in% c("Light_only","Diuron_only",  "Control")))
# 
# ggplot(Diuron_CItrend3) + aes(x = hours_fact, y = X50., colour = Treatment, fill = Treatment) + 
#   #geom_line(aes(x = as.integer(hours_fact))) + 
#   geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
#   geom_point(position = position_dodge2(0.5)) +
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
#     ylab(expression("I"[R])) 
# 
# ggsave("Figures/photo-inhib_Diuron-mod_IR.png", width = 20, height = 13, units = "cm", dpi = 300)
# 
# 
# # ggplot(Diuron_CItrend3) + aes(x = hours_fact, y = X50., colour = Treatment, fill = Treatment) + 
# #   #geom_line(aes(x = as.integer(hours_fact))) + 
# #   geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
# #   geom_point(position = position_dodge2(0.5)) +
# #   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
# #     ylab(expression("I"[R]))  + ylim(c(-0.5,1.5)) + ggtitle("Zoomed in")
# # 
# # 
# # ggsave("Figures/fluoro_Diuron-mod_IR_zoomed.png", width = 20, height = 13, units = "cm", dpi = 300)

```


### Diuron yield LRR plots


```{r}

# Generate some data for prediction
xdiuron_newdata <- with(psii_dat,{
  expand.grid(list(Light_num = unique(Light_num), Diuron_num = unique(Diuron_num), hours = unique(hours)))}) %>%
  mutate(block = 2, sample_id = psii_dat$sample_id[[1]], hours_fact = factor(hours), t0 = 0.6) 

# Make predictions based 
set.seed(1000)
diuron_bayes <- compute_CI_data(model = m1_diuron_yield, dat = xdiuron_newdata, nsims = 1000) %>% within({
  Treatment <- case_when(Light_num == 80 & Diuron_num == 0 ~ "Control",
    Light_num == 80  ~ "Diuron_only",
    Diuron_num == 0  ~ "Light_only",
    TRUE ~ "Light_Diuron")
  }) 

# # Generate the control matrix
diuron_bayes_control <- diuron_bayes %>% filter(Treatment == "Control")
diuron_control_mat <- diuron_bayes_control[ match(diuron_bayes$hours, diuron_bayes_control$hours) ,]

# Generate light only matrix
diuron_bayes_light <- diuron_bayes %>% filter(Diuron_num == 0)
diuron_light_mat <- diuron_bayes_light[ 
  match(paste(diuron_bayes$hours, diuron_bayes$Light_num), 
        paste(diuron_bayes_light$hours, diuron_bayes_light$Light_num)) ,]

# Generate diuron only matrix
diuron_bayes_diuron <- diuron_bayes %>% filter(Light_num == 80 )
diuron_mat <- diuron_bayes_diuron[ 
  match(paste(diuron_bayes$hours, diuron_bayes$Diuron_num), 
        paste(diuron_bayes_diuron$hours, diuron_bayes_diuron$Diuron_num)) ,]

# Compute the IR matrix
IR_mat2 <- log((select(diuron_bayes, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`))/
                ((select(diuron_light_mat, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`))*
                   (select(diuron_mat, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`))))

# col_invest <- "2"
# check <- cbind(select(diuron_bayes, Light_num:t0), 
#                data.frame(both = diuron_bayes[,col_invest], lightonly = diuron_light_mat[,col_invest], 
#                           diurononly =  diuron_mat[,col_invest], control = diuron_control_mat[,col_invest])) %>%
#   within({
#   both_diff <- control - both
#   light_diff <- control - lightonly
#   diuron_diff <- control - diurononly
#   denominator <- light_diff + diuron_diff
#   RR <- both_diff/denominator
#   LRR <-  log(RR)
#   })
rowSums(is.na(IR_mat2))


# # # Bool matrix to replace NANs with antag or synergism
# bool_mat2 <- (select(diuron_control_mat, `1`:`1000`) - select(diuron_bayes, `1`:`1000`)) < 0
# IR_mat2[is.na(IR_mat2) & bool_mat2] <- -5.5
# IR_mat2[is.na(IR_mat2) & !(bool_mat2)] <- 5.5


# Compute the credible intervals
Diuron_CItrend3 <- cbind(data.frame(t(apply(IR_mat2, 1, quantile, probs = c(0.025, 0.5, 0.975), na.rm = TRUE))), xdiuron_newdata) %>% within({
  Treatment <- case_when(Light_num == 80 & Diuron_num == 0 ~ "Control",
                         Light_num == 80  ~ "Diuron_only",
                         Diuron_num == 0  ~ "Light_only",
                        TRUE ~ paste0("Light = ", Light_num, ", Diuron = ", Diuron_num))}) %>% 
  filter(!(Treatment %in% c("Light_only","Diuron_only",  "Control")))

p2 <- ggplot(Diuron_CItrend3) + aes(x = hours_fact, y = X50., colour = Treatment, fill = Treatment) + 
  #geom_line(aes(x = as.integer(hours_fact))) + 
  geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
  geom_point(position = position_dodge2(0.5)) +
  # geom_point(aes(x = hours_fact, y = X97.5., colour = Treatment, alpha = (X97.5. == 5.5)),
  #            position = position_dodge2(0.5), shape = 2) + 
  # geom_point(aes(x = hours_fact, y = X2.5., colour = Treatment, alpha = (X2.5. == -5.5)),
  #            position = position_dodge2(0.5), shape = 6) + 
  geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
    ylab(expression("I"[R])) +guides(alpha = FALSE)

p2
ggsave("../Outputs/photo_yield_Diuron-mod_IR_2021-06-17.png", width = 20, height = 13, units = "cm", dpi = 300)


# ggplot(Diuron_CItrend3) + aes(x = hours_fact, y = X50., colour = Treatment, fill = Treatment) +
#   #geom_line(aes(x = as.integer(hours_fact))) +
#   geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
#   geom_point(position = position_dodge2(0.5)) +
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
#     ylab(expression("I"[R]))  + ylim(c(-50,50)) + ggtitle("Zoomed in")
# # 
# 
# ggsave("Figures/fluoro_Diuron-mod_IR_zoomed.png", width = 20, height = 13, units = "cm", dpi = 300)

```


```{r}

Diuron_photo_CI_data <- Diuron_CItrend3 %>% select(-block, -sample_id)

Diuron_photo_data <- psii_dat %>% select(hours, hours_fact, Light_num, Diuron_num, block, sample_id, t0, Yield) %>% within(Yield_pred <- predict(m1_diuron_yield, newdata = .))

save(Diuron_photo_CI_data, Diuron_photo_data, m1_diuron_yield, file = "../Data/Diuron_photo_model_and_data2.RDA")

```




```{r}

## Checks to ensure IR modelling is correct - seems to all be good

set.seed(306)

fake_block <- rnorm(n = 4, sd = 0.25, mean = 0)
fake_block <- rnorm(n = 4, sd = 0.25, mean = 0)
#sample_effect <- rnorm(60, sd = 0.25, mean = 0)[as.numeric(xdiuron_light2$sample_id)]

psii_dat_fake <- within(psii_dat, {

  Yield <- t0 + hours/(72) -(80-Light_num)/(80*4) - Diuron_num/(3*4) + 
    ifelse((80 - Light_num)*Diuron_num == 0, 0, 1 )*((24 - hours)/72) + 
    fake_block[as.numeric(block)] + 1.4 + #sample_effect +
    rnorm(300, mean = 0, sd = .10)
  
  check <- ifelse((80 - Light_num)*Diuron_num == 0, 0, 1 )*((24 - hours)/72*1.5) 
  
   Yield_C <- ifelse(Light_num == 80 & Diuron_num ==0, Yield, NA)

  }) %>% group_by(block, hours) %>% mutate(Yield_C = max(Yield_C, na.rm = TRUE)) %>% ungroup()

psii_dat <- psii_dat %>% group_by(block, hours) %>% mutate(Yield_C = max(ifelse(Light_num == 80 & Diuron_num ==0, Yield, NA), na.rm = TRUE)) %>% ungroup() %>% mutate(block_obs = 1 - Yield/Yield_C)

#look <- psii_dat %>% group_by(Light_num, hours, Diuron_num) %>% summarise(mean(block_obs))

# Test the metric approach
metric_approach <- psii_dat %>%
  mutate(block_obs = 1 - Yield/Yield_C) %>% 
  group_by(Light_num, hours, Diuron_num) %>% summarise(mean_block = mean(block_obs)) %>% 
  mutate(Treatment = case_when(Light_num == 80 & Diuron_num == 0 ~ "Control",
                         Light_num == 80  ~ "Diuron_only",
                         Diuron_num == 0  ~ "Light_only",
                        TRUE ~ "Light_diuron")) %>% 
  group_by(Light_num, hours) %>% mutate(Light_only = mean_block[Diuron_num == 0]) %>% 
  group_by(Diuron_num, hours) %>% mutate(Diuron_only = mean_block[Light_num == 80]) %>% 
  ungroup() %>% filter(Treatment == "Light_diuron") %>% within({
    
    metric <-  (1-Light_only)*(1-Diuron_only)-(1-mean_block)
    interaction_type <- ifelse(metric > 0, "Synergistic", "Antagonistic")

})


p1 <- ggplot(metric_approach, aes(y = metric, x = factor(hours), colour = paste(Light_num, Diuron_num))) +
  geom_point()+ theme_bw() + geom_abline(intercept = 0, slope = 0, linetype = "dashed")


p1
m1_diuron_yield <- gam(Yield ~ s(hours, k = 5) +
                         offset(t0)+
                      s(Diuron_num, Light_num, k = 15, by = hours_fact) +
                        #s(sample_id, bs = "re")+
                       #s(Light_num, k = 3, by = hours_fact) +
                       #s(Diuron_num, k = 5, by =hours_fact) +
                      s(block, bs = "re"),
                    data = psii_dat_fake)

par(mfrow = c(2,2))
gam.check(m1_diuron_yield)

library(patchwork)
p1 + p2


#ggsave("../Outputs/photo_yield_Diuron-model_checks.png", width = 30, height = 13, units = "cm", dpi = 300)
```

