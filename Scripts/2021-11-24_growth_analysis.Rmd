---
title: "Data analysis"
output: html_document
---

TODO:
Diuron is missing two observations in rep 1 



```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

```


```{r}

library(tidyr)
library(readxl)
library(dplyr)
library(ggplot2)
library(mgcv)
library(visreg)
library(patchwork)

```


## Read in data 

```{r}

files <- list.files(path = "../Data",pattern = "DIN_light_rep", full.names = TRUE)
xdin_light <- lapply(files, function(x) read.csv(x)) %>%
  bind_rows(.id = "id") %>% within(hours[hours == 0.3] <- 0.33)

# # Check that absorbances are different
# na.omit(read.csv(files[[1]])$Absorbance == read.csv(files[[3]])$Absorbance)

files <- list.files(path = "../Data", pattern = "diuron_light_rep", full.names = TRUE)

xdiuron_light <- lapply(files, function(x) read.csv(x)) %>%
  bind_rows(.id = "id") %>% within(hours[hours == 0.3] <- 0.33)

```

## Data processing and summarizing 

Let's just look at the averages 

Diuron and light 

```{r}

xdiuron_light2 <- xdiuron_light  %>% 
  filter(Replicate == "AVERAGE", Diuron != "Blank", hours >= 0) %>%
  group_by(hours, Light, Diuron, id) %>% 
  summarise(Absorbance = mean(Absorbance), X = paste(X, collapse = " ")) %>% ungroup() %>% 
  within({
    
    Diuron_num <-  case_when(Diuron == "AlgaeControl" ~ 0,
                             Diuron == "MeOH" ~ 0,
                             TRUE ~ as.numeric(Diuron)
                             )
    
    Light_num <-  as.numeric(Light)
  
    block <-  factor(id)
    
    hours_fact <- factor(hours)
    
    celld <- 4179.6 * Absorbance - 172.48
    t0 <- ifelse(hours == 0, celld, NA)
    
    }) %>% group_by(Light, Diuron, id ) %>% fill(t0) %>% 
  ungroup() %>%  
  mutate(sample_id = factor(gsub("."," ", x = paste(Diuron, Light, block), fixed = TRUE))) %>% 
  filter(hours != 0, Diuron != "MeOH") %>% 
  mutate(Diuron_fact = factor(ifelse(Diuron == "AlgaeControl", "0", Diuron)))
  

```

DIN and light

```{r}

DIN_transform <- function(x) { log10(x + 12) }

xdin_light2 <- xdin_light  %>% 
  filter(Replicate == "AVERAGE", DIN != "Blank", hours >= 0) %>%
  group_by(hours, Light, DIN, id) %>% 
  summarise(Absorbance = mean(Absorbance), X = paste(X, collapse = " ")) %>% ungroup() %>% 
  within({
    
    DIN_num  <- case_when(
      DIN == "AlgaeControl" ~ 0,
      TRUE ~ as.numeric(DIN))
    
    log10DIN <- DIN_transform(DIN_num)
    
    fourRDIN <- (DIN_num)^(1/4)
    
    Light_num <-  as.numeric(Light)
  
    block <-  factor(id)
    
    hours_fact <- factor(hours)
    
    celld <- 4179.6 * Absorbance - 172.48
    t0 <- ifelse(hours == 0, celld, NA)
    
    }) %>% group_by(Light, DIN, id ) %>% fill(t0) %>% 
  ungroup() %>%  
  mutate(sample_id = factor(gsub("."," ", x = paste(DIN, Light, block), fixed = TRUE))) %>% 
  filter(hours != 0)


```

## Analysis of DIN and light 

```{r}
ggplot(xdin_light2) + 
  aes(x = as.numeric(hours), y = celld, color = factor(DIN_num)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()
```

Model fitting and checking diagnostics. Fit a model with 2-way interaction between DIN and Light that can vary over time. Looks like it fits ok

```{r}

# method = REML or ML seems to be undersmoothing data
m1_din_light <- gam(log(celld) ~ 0 + hours_fact + offset(log(t0)) +
                      s(DIN_num, Light_num, k = 15, by = hours_fact) +  
                      #s(sample_id, bs = "re")+
                       #s(Light_num, k = 3, by = hours_fact, bs = "cr") +
                       #s(log10DIN, k = 5, by =hours_fact, bs = "cr") +
                      s(block, bs = "re"), 
                    data = xdin_light2)

vis.gam(x = m1_din_light,                # GAM object
        view = c("DIN_num", "Light_num"),   # variables
        plot.type = "contour", cond = list(hours = 0.33)) 

par(mfrow = c(2,2))
gam.check(m1_din_light)
```

```{r}

png(filename = "../Outputs/DIN_GAM_residuals.png", width = 20, height = 20, units = "cm", res = 300)
par(mfrow = c(2,2))
gam.check(m1_din_light)
dev.off()

```

Summary of model effects. Block doesn't matter (well done!). Complex three way interaction (significant) between hours, DIN and Light. 

```{r}
summary(m1_din_light)
```
Above model explains 72% of data variance. Model selection could be improved if we used AIC to identify optimal model structure. To do later. 

Model fit for celld by time

```{r}
visreg(m1_din_light, xvar = "hours")
```
Effect of DIN and light at 24 hours

```{r}
visreg(m1_din_light, xvar = "Light_num", by = "DIN_num",
cond = list(hours = 24))
```

Effect of DIN and light at 72 hours 
```{r}
visreg(m1_din_light, xvar = "Light_num", by = "DIN_num",
cond = list(hours = 72))

```

```{r}
visreg(m1_din_light, xvar = "DIN_num", by = "Light_num",
cond = list(hours = 72))

```

```{r}
plot(y = resid(m1_din_light), x = xdin_light2$hours)
lines(lowess(y = resid(m1_din_light), x = xdin_light2$hours), col = "blue")

itsadug::acf_resid(m1_din_light, split_pred=c("Light_num","DIN_num" ), main="ACF resid(m1)")


```


### Summary

From this (very preliminary analysis) I conclude: 

celld increases with time. 
DIN and light effect is stronger at longer times
Light has humped shaped relationship, with celld peaking about 30. 
DIN increases celld slightly in 26.2 treatement compared to other treatments. 



#### Make credible interval functions
```{r}

## MVN random deviates function
rmvn <- function(n,mu,sig) {
  L <- mroot(sig)
  m <- ncol(L)
  t(mu + L%*%matrix(rnorm(m*n),m,n)) 
}

### Function to compute the credible interval data

compute_CI_data <- function(model, dat, nsims = 1000){
  
  Xp <- predict(model,dat,type="lpmatrix") # Get linear predictor matrix minus the offset

  which_re <- grepl("block|sample", names(coef(model)))
  mean_block_effect <- coef(model)[grepl("block", names(coef(model)))] %>% mean()
  #mean_sample_id_effect <- coef(model)[grepl("sample", names(coef(model)))] %>% mean()
  
  # 1000 replicate param. vectors
  br <- rmvn(nsims,coef(model),model$Vp) 
  
  # Remove random effects columns to make condition on average random effect levels
  Xp <- Xp[,!which_re]
  br <- br[, !which_re]
  

# Intialise the matrix for storage of celld estimates
celldmult <- matrix(NA, nrow = nrow(dat), ncol = nsims)

for (i in 1:nsims){ 
  pr <- Xp %*% br[i,] + mean_block_effect #+ mean_sample_id_effect ## replicate predictions
  celldmult[,i] <- pr 
}

# Convert predictions to the natural scale (added offset here) and bind to the data
df_bayes <- cbind(dat, exp(celldmult + log(dat$t0))) 

return(df_bayes)

}

```


### DIN LRR plots

```{r}

## Generate some data for prediction
xdin_newdata <- with(xdin_light2,{
  expand.grid(list(Light_num = unique(Light_num), DIN_num = unique(DIN_num), hours = unique(hours)))}) %>%
  mutate(block = 2, 
         sample_id = xdin_light2$sample_id[[1]], log10DIN = DIN_transform(DIN_num), 
         hours_fact = factor(hours), t0 = 87) 

# Make predictions based 
set.seed(30)
df_bayes <- compute_CI_data(model = m1_din_light, dat = xdin_newdata, nsims = 1000) %>% within({
  Treatment <- case_when(Light_num == 80 & DIN_num == 0 ~ "Control",
                         Light_num == 80  ~ "DIN_only",
                         DIN_num == 0  ~ "Light_only",
                        TRUE ~ "Light_DIN")
  }) 

# Generate the control matrix
df_bayes_control <- df_bayes %>% filter(Treatment == "Control")
control_mat <- df_bayes_control[ match(df_bayes$hours, df_bayes_control$hours) ,]

# # Compute the LRR matrix
# LRR_mat<- log(select(df_bayes, `1`:`1000`)/select(control_mat, `1`:`1000`)) 
# 
# # Compute the credible intervals
# CItrend <- cbind(data.frame(t(apply(LRR_mat, 1, quantile, probs = c(0.025, 0.5, 0.975)))), xdin_newdata)
# 
# ## Generate some more CIs
# 
# xdin_newdata2 <- with(xdin_light2,{
#   expand.grid(list(Light_num = seq(min(Light_num), max(Light_num),1), DIN_num  = c(0, 2.67 * 10^seq(-2, 1, by = 0.05)), hours = unique(hours)))}) %>% 
#   mutate(block = 2, sample_id = xdin_light2$sample_id[[1]], log10DIN = DIN_transform(DIN_num), hours_fact = factor(hours), t0 = 87) 
# 
# # Make predictions based 
# set.seed(52)
# df_bayes2 <- compute_CI_data(model = m1_din_light, dat = xdin_newdata2, nsims = 1000) %>% within({
#   Treatment <- case_when(Light_num == 80 & DIN_num == 0 ~ "Control",
#                          Light_num == 80  ~ "DIN_only",
#                          DIN_num == 0  ~ "Light_only",
#                         TRUE ~ "Light_DIN")
#   }) 
# 
# # Generate the control matrix
# df_bayes_control2 <- df_bayes2 %>% filter(Treatment == "Control")
# control_mat2 <- df_bayes_control[ match(df_bayes2$hours, df_bayes_control2$hours) ,]
# 
# # Compute the LRR matrix
# LRR_mat2<- log(select(df_bayes2, `1`:`1000`)/select(control_mat2, `1`:`1000`)) 
# 
# # Compute the credible intervals
# CItrend2 <- cbind(data.frame(t(apply(LRR_mat2, 1, quantile, probs = c(0.025, 0.5, 0.975)))), xdin_newdata2)
# 
# ##
# 
# p1 <- ggplot(filter(CItrend, Light_num == 80, !(DIN_num %in% c(0, 0.0267, 0.267)))) + 
#   aes(x = hours_fact, y = X50., colour = as.factor(DIN_num)) + 
#   labs(colour = "DIN") +
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.3)) + 
#   geom_point(position = position_dodge2(0.3)) + theme_classic() + 
#   geom_hline(yintercept = 0, lty= "dashed") + xlab("Hours")  + ylab("LRR")#+ theme(legend.position = c(0.85, 0.8))
# 
# p2 <- ggplot(filter(CItrend, DIN_num == 0, Light_num != 80)) + 
#   aes(x = hours_fact, y = X50., colour = as.factor(Light_num)) + 
#   labs(colour = "Light") +
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.3)) + 
#   geom_point(position = position_dodge2(0.3)) + theme_classic() + 
#   geom_hline(yintercept = 0, lty= "dashed") + xlab("Hours") + ylab("LRR")#+ theme(legend.position = c(0.85, 0.8))
# 
# p3 <- ggplot(filter(CItrend2, DIN_num == 0)) + 
#   aes(x = Light_num, y = X50., colour = hours_fact, fill = hours_fact) + 
#   labs(colour = "Hours elasped") + guides(fill = FALSE, colour = FALSE) +
#   geom_ribbon(mapping = aes(ymin = X2.5., ymax = X97.5.), alpha = 0.2) +
#   geom_line() + theme_classic() + geom_hline(yintercept = 0, lty= "dashed") +
#   xlab("Light") + ylab("LRR")
# 
# p4 <- ggplot(filter(CItrend2, Light_num == 80)) + 
#   aes(x = DIN_num, y = X50., colour = hours_fact, fill = hours_fact) + #scale_x_log10() +
#   labs(colour = "Hours elasped") + guides(fill = FALSE, colour = FALSE) +
#   geom_ribbon(mapping = aes(ymin = X2.5., ymax = X97.5.), alpha = 0.2) + 
#   geom_line() +theme_classic() + geom_hline(yintercept = 0, lty= "dashed") +
#     xlab("DIN") + ylab("LRR")
# 
# 
# 
# p1 + p2
# 
# ggsave("Figures/DIN-mod_DIN_light_LRR.png", width = 20, height = 8, units = "cm", dpi = 300)
# 
# p3 + facet_wrap(.~hours_fact)
# 
# ggsave("Figures/DIN-mod_Light_LRR.png", width = 20, height = 14, units = "cm", dpi = 300)
# 
# p4 + facet_wrap(.~hours_fact)
# 
# ggsave("Figures/DIN-mod_DIN_LRR.png", width = 20, height = 14, units = "cm", dpi = 300)

```

### DIN IR plots

```{r}

# Generate the control matrix
df_bayes_control <- df_bayes %>% filter(Treatment == "Control")
control_mat <- df_bayes_control[ match(df_bayes$hours, df_bayes_control$hours) ,]

# Generate light only matrix
df_bayes_light <- df_bayes %>% filter(DIN_num == 0)
light_mat <- df_bayes_light[ match(paste(df_bayes$hours, df_bayes$Light_num), 
                               paste(df_bayes_light$hours, df_bayes_light$Light_num)) ,]

# Generate DIN only matrix
df_bayes_DIN <- df_bayes %>% filter(Light_num == 80)
DIN_mat <- df_bayes_DIN[ match(paste(df_bayes$hours, df_bayes$DIN_num), 
                               paste(df_bayes_DIN$hours, df_bayes_DIN$DIN_num)) ,]

# Compute the IR matrix
IR_mat <- log((select(df_bayes, `1`:`1000`)/select(control_mat, `1`:`1000`))/
                ((select(light_mat, `1`:`1000`)/select(control_mat, `1`:`1000`))*(select(DIN_mat, `1`:`1000`)/select(control_mat, `1`:`1000`)))) 


# col_invest <- "2"
# 
# check <- cbind(select(df_bayes, Light_num:t0), 
#                data.frame(both = df_bayes[,col_invest], lightonly = light_mat[,col_invest], 
#                           DINonly =  DIN_mat[,col_invest], control = control_mat[,col_invest])) %>%
#   within({
#   both_diff <- control - both
#   light_diff <- control - lightonly
#   DIN_diff <- control - DINonly
#   denominator <- light_diff + DIN_diff
#   RR <- both_diff/denominator
#   LRR <-  log(RR)
#   })

rowSums(is.na(IR_mat))

# # Bool matrix to replace NANs with antag or synergism
# bool_mat <- (select(control_mat, `1`:`1000`) - select(df_bayes, `1`:`1000`)) < 0
# IR_mat[is.na(IR_mat) & bool_mat] <- -5.5
# IR_mat[is.na(IR_mat) & !(bool_mat)] <- 5.5

# Compute the credible intervals
CItrend3 <- cbind(data.frame(t(apply(IR_mat, 1, quantile, probs = c(0.025, 0.5, 0.975), na.rm = TRUE))), xdin_newdata) %>% within({
  Treatment <- case_when(Light_num == 80 & DIN_num == 0 ~ "Control",
                         Light_num == 80  ~ "DIN_only",
                         DIN_num == 0  ~ "Light_only",
                        TRUE ~ paste0("Light = ", Light_num, ", DIN = ", DIN_num))}) %>% 
  filter(!(Treatment %in% c("Light_only","DIN_only",  "Control")), !(DIN_num %in% c(0.0267, 0.267)))

ggplot(CItrend3) + aes(x = hours_fact, y = X50., colour = Treatment, fill = Treatment) + geom_point(position = position_dodge2(0.4)) +
  #geom_line(aes(x = as.integer(hours_fact))) + 
  geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
  geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.4)) +
    ylab(expression("I"[R])) + guides(alpha = FALSE)

ggsave("../Outputs/DIN-mod_IR_2021-06-17.png", width = 20, height = 13, units = "cm", dpi = 300)

```


```{r}
# Save data for plotting
DIN_growth_CI_data <- CItrend3 %>% select(-block, -sample_id)

DIN_growth_data <- xdin_light2 %>% select(hours, hours_fact, Light_num, DIN_num, block, sample_id, t0, celld) %>% within(celld_pred <- exp(predict(m1_din_light, newdata = .)))

save(DIN_growth_CI_data, DIN_growth_data, m1_din_light, file = "../Data/DIN_growth_model_and_data2.RDA")

```


# Analysis of Diuron and light 

Below pools meth control and control. 

```{r}
ggplot(xdiuron_light2) + 
  aes(x = hours, y = celld, color = factor(Diuron_num)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()

ggplot(xdiuron_light2) + 
  aes(x = hours, y = celld, color = factor(block)) + 
  geom_point() + 
  facet_grid(.~ Light_num, scales = "free") + 
  stat_smooth(se = FALSE) + 
  theme_classic()

```

Fits same model as above but with Diuron instead of DIN. Residuals look a bit skewif if we include block 1. Better if we exclude block 1, check later. 

```{r}

xdiuron_light2 <- xdiuron_light2 %>% filter(block != "1")
m1_diuron_light <- gam(log(celld) ~ 0 + hours_fact + offset(log(t0)) +
                      s(Diuron_num, Light_num, k = 15, by = hours_fact) +
                        #s(sample_id, bs = "re")+
                       # s(Light_num, k = 3, by = hours_fact) +
                       # s(Diuron_num, k = 5, by =hours_fact) +
                      s(block, bs = "re"),
                    data = xdiuron_light2)
# 
# m1_diuron_tsmooth <-gam(log(celld) ~ 0 + Diuron_fact + offset(log(t0)) +
#                       s(hours, Light_num, k = 15, by = Diuron_fact) +  
#                        s(sample_id,bs = "re")+
#                       s(block, bs = "re"), 
#                     data = xdiuron_light2)

gam.check(m1_diuron_light)
#gam.check(m1_diuron_tsmooth)
```

```{r}

png(filename = "../Outputs/Diuron_GAM_residuals.png", width = 20, height = 20, units = "cm", res = 300)
par(mfrow = c(2,2))
gam.check(m1_diuron_light)
dev.off()

```

Everythign matters here, include block. 

```{r}
summary(m1_diuron_light)
```

74% of variance is explained. 


Model fit for celld by time

```{r}
visreg(m1_diuron_light, xvar = "hours")
```
Effect of Diuron and light at zero hours

```{r}
visreg(m1_diuron_light, xvar = "Light_num", by = "Diuron_fact", 
       cond = list(hours = 0))
```

Effect of DIN and light at 72 hours 
```{r}
visreg(m1_diuron_light, xvar = "Light_num", by = "Diuron_num",
cond = list(hours = 72))

```



### Diuron LRR plots


```{r}

# Generate some data for prediction
xdiuron_newdata <- with(xdiuron_light2,{
  expand.grid(list(Light_num = unique(Light_num), Diuron_num = unique(Diuron_num), hours = unique(hours)))}) %>%
  mutate(block = 2, sample_id = xdiuron_light2$sample_id[[1]], hours_fact = factor(hours), t0 = 87) 

# Make predictions based 
set.seed(1000)
diuron_bayes <- compute_CI_data(model = m1_diuron_light, dat = xdiuron_newdata, nsims = 1000) %>% within({
  Treatment <- case_when(Light_num == 80 & Diuron_num == 0 ~ "Control",
                         Light_num == 80  ~ "Diuron_only",
                         Diuron_num == 0  ~ "Light_only",
                        TRUE ~ "Light_DIN")
  }) 

# Generate the control matrix
diuron_bayes_control <- diuron_bayes %>% filter(Treatment == "Control")
diuron_control_mat <- diuron_bayes_control[ match(diuron_bayes$hours, diuron_bayes_control$hours) ,]

# Compute the LRR matrix
diuron_LRR_mat<- log(select(diuron_bayes, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`)) 

# Compute the credible intervals
diuron_CItrend <- cbind(data.frame(t(apply(diuron_LRR_mat, 1, quantile, probs = c(0.025, 0.5, 0.975)))), xdiuron_newdata)


# ## Generate some more predictions
# xdiuron_newdata2 <- with(xdiuron_light2,{
#   expand.grid(list(Light_num = seq(min(Light_num), max(Light_num),1), Diuron_num  = seq(min(Diuron_num), max(Diuron_num),0.1), hours = unique(hours)))}) %>% 
#   mutate(block = 2, sample_id = xdiuron_light2$sample_id[[1]], hours_fact = factor(hours), t0 = 87) 
# 
# # Make predictions based 
# set.seed(10000)
# diuron_bayes2 <- compute_CI_data(model = m1_diuron_light, dat = xdiuron_newdata2, nsims = 1000) %>% within({
#   Treatment <- case_when(Light_num == 80 & Diuron_num == 0 ~ "Control",
#                          Light_num == 80  ~ "Diuron_only",
#                          Diuron_num == 0  ~ "Light_only",
#                         TRUE ~ "Light_DIN")
#   }) 
# 
# # Generate the control matrix
# diuron_bayes_control2 <- diuron_bayes2 %>% filter(Treatment == "Control")
# diuron_control_mat2 <- diuron_bayes_control2[ match(diuron_bayes2$hours, diuron_bayes_control2$hours) ,]
# 
# # Compute the LRR matrix
# diuron_LRR_mat2<- log(select(diuron_bayes2, `1`:`1000`)/select(diuron_control_mat2, `1`:`1000`)) 
# 
# # Compute the credible intervals
# diuron_CItrend2 <- cbind(data.frame(t(apply(diuron_LRR_mat2, 1, quantile, probs = c(0.025, 0.5, 0.975)))), xdiuron_newdata2)
# 
# 
# 
# p1 <- ggplot(filter(diuron_CItrend, Light_num == 80, Diuron_num != 0)) + 
#   aes(x = hours_fact, y = X50., colour = as.factor(Diuron_num)) + labs(colour = "Diuron") + 
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
#   geom_point(position = position_dodge2(0.5)) +ylab("LRR") +
#   theme_classic() + geom_hline(yintercept = 0, lty= "dashed") + xlab("Hours") #+ theme(legend.position = c(0.85, 0.8))
# 
# p2 <- ggplot(filter(diuron_CItrend, Diuron_num == 0, Light_num != 80)) + 
#   aes(x = hours_fact, y = X50., colour = as.factor(Light_num)) + labs(colour = "Light") +
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.3)) +
#   geom_point(position = position_dodge2(0.3)) + ylab("LRR") +
#   theme_classic() + geom_hline(yintercept = 0, lty= "dashed") + xlab("Hours") #+ theme(legend.position = c(0.85, 0.8))
# 
# p3 <- ggplot(filter(diuron_CItrend2, Diuron_num == 0)) + 
#   aes(x = Light_num, y = X50., colour = hours_fact, fill = hours_fact) + #scale_x_log10() +
#   labs(colour = "Hours elasped") + guides(fill = FALSE, colour = FALSE) +
#   geom_ribbon(mapping = aes(ymin = X2.5., ymax = X97.5.), alpha = 0.2) + 
#   geom_line() +theme_classic() + geom_hline(yintercept = 0, lty= "dashed") +
#     xlab("Light") + ylab("LRR")
# 
# p4 <- ggplot(filter(diuron_CItrend2, Light_num == 80)) +
#   aes(x = Diuron_num, y = X50., colour = hours_fact, fill = hours_fact) + #scale_x_log10() +
#   labs(colour = "Hours elasped") + guides(fill = FALSE, colour = FALSE) +
#   geom_ribbon(mapping = aes(ymin = X2.5., ymax = X97.5.), alpha = 0.2) + 
#   geom_line() +theme_classic() + geom_hline(yintercept = 0, lty= "dashed") +
#     xlab("Diuron") + ylab("LRR")
# 
# 
# 
# p1 + p2
# 
# ggsave("Figures/Diuron-mod_Diuron_light_LRR.png", width = 20, height = 8, units = "cm", dpi = 300)
# 
# p3 + facet_wrap(.~hours_fact)
# 
# ggsave("Figures/Diuron-mod_Light_LRR.png", width = 20, height = 14, units = "cm", dpi = 300)
# 
# p4 + facet_wrap(.~hours_fact)
# 
# ggsave("Figures/Diuron-mod_Diuron_LRR.png", width = 20, height = 14, units = "cm", dpi = 300)

```

### Diuron IR plots

```{r}

# Generate the control matrix
diuron_bayes_control <- diuron_bayes %>% filter(Treatment == "Control")
diuron_control_mat <- diuron_bayes_control[ match(diuron_bayes$hours, diuron_bayes_control$hours) ,]


# Generate light only matrix
diuron_bayes_light <- diuron_bayes %>% filter(Diuron_num == 0)
diuron_light_mat <- diuron_bayes_light[ 
  match(paste(diuron_bayes$hours, diuron_bayes$Light_num), 
        paste(diuron_bayes_light$hours, diuron_bayes_light$Light_num)) ,]

# Generate diuron only matrix
diuron_bayes_diuron <- diuron_bayes %>% filter(Light_num == 80 )
diuron_mat <- diuron_bayes_diuron[ 
  match(paste(diuron_bayes$hours, diuron_bayes$Diuron_num), 
        paste(diuron_bayes_diuron$hours, diuron_bayes_diuron$Diuron_num)) ,]

# Compute the IR matrix
IR_mat2 <- log((select(diuron_bayes, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`))/
                ((select(diuron_light_mat, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`))*
                   (select(diuron_mat, `1`:`1000`)/select(diuron_control_mat, `1`:`1000`))))

# col_invest <- "2"
# check <- cbind(select(diuron_bayes, Light_num:t0),
#                data.frame(both = diuron_bayes[,col_invest], lightonly = diuron_light_mat[,col_invest],
#                           diurononly =  diuron_mat[,col_invest], control = diuron_control_mat[,col_invest])) %>%
#   within({
#   both_diff <- control - both
#   light_diff <- control - lightonly
#   diuron_diff <- control - diurononly
#   denominator <- light_diff + diuron_diff
#   RR <- both_diff/denominator
#   LRR <-  log(RR)
#   })
# rowSums(is.na(IR_mat2))

# # # Bool matrix to replace NANs with antag or synergism
# bool_mat2 <- (select(diuron_control_mat, `1`:`1000`) - select(diuron_bayes, `1`:`1000`)) < 0
# IR_mat2[is.na(IR_mat2) & bool_mat2] <- -5.5
# IR_mat2[is.na(IR_mat2) & !(bool_mat2)] <- 5.5

# Compute the credible intervals
Diuron_CItrend3 <- cbind(data.frame(t(apply(IR_mat2, 1, quantile, probs = c(0.025, 0.5, 0.975), na.rm = TRUE))), xdiuron_newdata) %>% within({
  Treatment <- case_when(Light_num == 80 & Diuron_num == 0 ~ "Control",
                         Light_num == 80  ~ "Diuron_only",
                         Diuron_num == 0  ~ "Light_only",
                        TRUE ~ paste0("Light = ", Light_num, ", Diuron = ", Diuron_num))}) %>% 
  filter(!(Treatment %in% c("Light_only","Diuron_only",  "Control")))

ggplot(Diuron_CItrend3) + aes(x = factor(hours), y = X50., colour = Treatment, fill = Treatment) + 
  #geom_line(aes(x = as.integer(hours_fact))) + 
  geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
  geom_point(position = position_dodge2(0.5)) + 
  geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
    ylab(expression("I"[R])) + guides(alpha = FALSE)

ggsave("../Outputs/Diuron-mod_IR_2021-06-17.png", width = 20, height = 13, units = "cm", dpi = 300)


# ggplot(Diuron_CItrend3) + aes(x = hours_fact, y = X50., colour = Treatment, fill = Treatment) + 
#   #geom_line(aes(x = as.integer(hours_fact))) + 
#   geom_hline(yintercept = 0, lty= "dashed") +theme_classic() + xlab("Hours") +
#   geom_point(position = position_dodge2(0.5)) +
#   geom_linerange(mapping = aes(ymin = X2.5., ymax = X97.5.), position = position_dodge2(0.5)) +
#     ylab(expression("I"[R]))  + ylim(c(-0.5,.5)) + ggtitle("Zoomed in")
# 
# 
# ggsave("Figures/Diuron-mod_IR_zoomed.png", width = 20, height = 13, units = "cm", dpi = 300)

```


```{r}
# Save data for plotting
Diuron_growth_CI_data <- Diuron_CItrend3 %>% select(-block, -sample_id)

Diuron_growth_data <- xdiuron_light2 %>% select(hours, hours_fact, Diuron_fact, Light_num, Diuron_num, block, sample_id, t0, celld) %>% within(celld_pred <- exp(predict(m1_diuron_light, newdata = .)))

save(Diuron_growth_CI_data, Diuron_growth_data, m1_diuron_light, file = "../Data/Diuron_growth_model_and_data2.RDA")

```



```{r}

## Checks to ensure IR modelling is correct - seems to all be good

set.seed(50)
fake_block <- rnorm(n = 4, sd = 0.025, mean = 0)
sample_error <- rnorm(225, sd = 0.025)
sample_effect <- rnorm(60, sd = 0.025, mean = 0)[as.numeric(xdiuron_light2$sample_id)]
xdiuron_light2_fake <- within(xdiuron_light2, {
  
  celld <- t0 * exp(hours/72 - (80 -Light_num)/(80*4) - Diuron_num/(3*4) - ifelse((80 - Light_num)*Diuron_num == 0, 0, 1 )*(24 - hours)/48 + 
    fake_block[as.numeric(block)] + sample_error + sample_effect
    )
  celld2 <- exp(-ifelse((80 - Light_num)*Diuron_num == 0, 0, 1 )*abs((24 - hours))/48)
  
  
  })

xdin_light2_fake <- within(xdin_light2, {
  
  celld <- t0 * exp(hours/72 - (80 -Light_num)/(80*4) - DIN_num/(26.7*4) - ifelse((80 - Light_num)*DIN_num == 0, 0, 1 )*(24 - hours)/48+ 
    fake_block[as.numeric(block)] + sample_error)
  
  })

m1_diuron_light <- gam(log(celld) ~ 0 + hours_fact + offset(log(t0)) +
                      s(Diuron_num, Light_num, k = 15, by = hours_fact) +
                         #s(sample_id, bs = "re")+
                       # s(Light_num, k = 3, by = hours_fact) +
                       # s(Diuron_num, k = 5, by =hours_fact) +
                      s(block, bs = "re"),
                    data = xdiuron_light2_fake)

m1_din_light <- gam(log(celld) ~ 0 + hours_fact + offset(log(t0)) +
                      s(DIN_num, Light_num, k = 15, by = hours_fact) +  
                      s(sample_id, bs = "re")+
                       #s(Light_num, k = 3, by = hours_fact) +
                       #s(DIN_num, k = 5, by =hours_fact) +
                      s(block, bs = "re"), 
                    data = xdin_light2_fake)

```